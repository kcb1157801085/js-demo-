<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>


/*
1、在内存中申请一块空闲的空间，存储创建的对象
1、调用系统Object()---创建出来的对象都是Object类型的，不能很明确的指出这个对象是属于什么类型
2、this就是当前实例化的对象
2、字面量的方式{}----只能创建一个对象（一次只能创建一个）
3、工厂模式创建对象---推论---自定义构造函数的方式
3、设置对象中的属性和方法（为对象添加属性和方法，为属性和方法赋值）
4、把创建后的对象返回都是需要通过new的方式
什么是原型?
创建对象的方式
复习：
实例对象中有一个属性__proto__,是原型，浏览器使用的，不是标准的
实例对象的原型对象（__proto__）指向的是该构造函数的原型对象
对象：具体特指的某个事物，有特征（属性）和行为(方法)
封装：就是代码的封装，把一些特征和行为封装在对象中
构造函数中有一个属性prototype，是原型，程序员使用的
构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问的
正常的写法：实例对象.__proto__才能访问到构造函数中的prototype中的属性和方法
注重的是过程
自定义构造函数创建对象：4件事
自定义构造函数（优化后的工厂模式）
面向对象的特征：封装，继承，多态
面向对象的编程思想：根据需求，抽象出相关的对象，总结对象的特征和行为，把特征变成属性，把行为变成方法，
然后定义构造函数，实例化对象，通过对象调用属性和方法，完成相应的需求---编程的思想
面向对象：执行者成为指挥者，只要找对象，然后让对象做相关的事情，注重的是结果
面向过程和面向对象都是编程思想，方式不一样
面向过程：凡事都是亲力亲为，所有的代码都要自己写，每一步都要很清楚
per.__proto__.eat();//__proto__不是标准的属性
per.eat();
原型就是属性的，而这个属性也是一个对象
Person.prototype---是属性
Person.prototype.属性或者person.proto.方法()

本身在构造函数中定义的属性和方法，当实例化对象的时候，实例对象中的属性和方法都是在自己的空间中存在，
如果是多个对象。这些属性和方法都会在单独的空间中存在，浪费内存空间，所以，为了数据共享，
把想要节省的属性或者方法写在原型对象中，达到了数据共享，实现了节点内存空间。


原型的作用之一：数据共享，节省内存空间
原型的写法：
构造函数.prototype.属性=值
构造函数。prototype.方法=值---函数.prototype,函数也是对象，所以，里面也有__proto__
实例对象.prototype----实例对象红没有这个属性，只有__proto__（暂时的）

简单的原型的写法
缺陷-----新的知识点---原型直接指向{}---就是一个对象，没有构造器
构造函数.prototype = {
	切记：如果这种写法，要把构造器加上
};


通过原型为内置对象添加原型的属性或者方法--原因：
系统的内存对象的属性和方法可能不满足现在需求，所以，可以通过原型的方式加入属性或者方法，为了方便开发

为内置对象的原型中添加属性的方法，那么这个内置对象的实例对象就可以直接使用了
String.prototype.方法=匿名函数;
var str="呵呵";
str.方法();---实例对象可以直接调用原型中的属性或者方法
 */






















	</script>


<script>

//页面的任何位置.按下键盘，获取按键的值，可根据这个值测试出每个值所代表的键盘按键
document.onkeydown=function(e){
  console.log(e.keyCode);
}











</script>







</body>
</html>




































































































































